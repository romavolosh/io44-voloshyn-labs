# Аналіз Функціональних Залежностей (ФЗ)

Ми проаналізували три таблиці: **users**, **levels**, **votes**.

## Таблиця: users

- **Ключ:** `user_id`
- **ФЗ:** `user_id → username, created_at`
- **Аналіз:** Значення username та created_at безпосередньо залежать від ID користувача. Аномалій немає.

## Таблиця: levels

- **Ключ:** `level_id`
- **ФЗ:** `level_id → name, placement, moderation, public`
- **Аналіз:** Всі характеристики рівня залежать від його унікального ідентифікатора. Аномалій немає.

## Таблиця: votes (Кандидат на покращення)

- **Ключ:** Складений `(user_id, level_id)`
- **ФЗ:** `{user_id, level_id} → is_agree, voted_at`

### Аналіз:

- Поле `is_agree` є булевим (`TRUE` = ЗА, `FALSE` = ПРОТИ).
- **Потенційна проблема гнучкості:** Якщо в майбутньому ми захочемо додати варіант "Утримався" або "Супер-лайк", булевий тип даних не дозволить це зробити без зміни структури таблиці (DDL).
- **Рішення:** Винести типи голосів у окрему таблицю-довідник (Lookup Table). Це замінить "жорстко закодоване" значення на зовнішній ключ.

---

# Перевірка нормальних форм та кроки нормалізації

## Крок 1: Перша нормальна форма (1NF)

**Вимога:** Усі атрибути мають бути атомарними (жодних списків через кому), кожен рядок унікальний.

- **Поточний стан:** Усі таблиці (`users`, `levels`, `votes`) вже знаходяться в 1NF. Ми не зберігаємо списки рівнів у комірці користувача (наприклад, "1, 2, 5") і не зберігаємо списки користувачів у таблиці рівнів.
- **Дія:** Змін не потрібно.

## Крок 2: Друга нормальна форма (2NF)

**Вимога:** Таблиця в 1NF, і всі неключові атрибути залежать від повного первинного ключа (немає часткових залежностей).

### Аналіз таблиці votes:

- **Первинний ключ:** `(user_id, level_id)`
- **Атрибут `voted_at`:** залежить від факту голосування (тобто від комбінації Користувач + Рівень). Ми не можемо знати час голосування, знаючи лише користувача.
- **Атрибут `is_agree`:** залежить від комбінації Користувач + Рівень.

**Висновок:** Часткових залежностей немає. Таблиці в 2NF.

## Крок 3: Третя нормальна форма (3NF) та покращення дизайну

**Вимога:** Таблиця в 2NF, і немає транзитивних залежностей (неключові атрибути не залежать від інших неключових атрибутів).

- **Поточний стан:** Транзитивних залежностей немає (наприклад, у нас немає поля city та zip_code в таблиці users, де zip → city).

### Запропоноване покращення (Refinement)

Зараз тип голосу (`is_agree`) є булевим. Хоча це технічно 3NF, з точки зору дизайну баз даних, краще нормалізувати варіанти вибору.

Замість `is_agree` (BOOLEAN) ми створимо сутність `vote_types` і посилатимемось на неї.

#### Перетворення:

1. Створити таблицю `vote_types`
2. У таблиці `votes` замінити `is_agree` на `vote_type_id`
